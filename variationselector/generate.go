//go:build ignore

// Copyright (c) 2024 Tulir Asokan
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"

	"golang.org/x/exp/slices"

	"go.mau.fi/util/exerrors"
)

const UnicodeVersion = "15.1"

func readEmojiLines(url, filter string) (output []string) {
	resp := exerrors.Must(http.Get(url))
	buf := bufio.NewReader(resp.Body)
	for {
		line, err := buf.ReadString('\n')
		if errors.Is(err, io.EOF) {
			break
		} else if err != nil {
			panic(err)
		}
		parts := strings.Split(line, "; ")
		if len(parts) < 2 || !strings.HasPrefix(parts[1], filter) {
			continue
		}
		output = append(output, strings.TrimSpace(parts[0]))
	}
	return
}

func unifiedToUnicode(input string) string {
	parts := strings.Split(input, " ")
	output := make([]rune, len(parts))
	for i, part := range parts {
		output[i] = rune(exerrors.Must(strconv.ParseInt(part, 16, 32)))
	}
	return string(output)
}

func main() {
	variationSequences := readEmojiLines("https://www.unicode.org/Public/"+UnicodeVersion+".0/ucd/emoji/emoji-variation-sequences.txt", "emoji style")
	fullyQualifiedSequences := readEmojiLines("https://unicode.org/Public/emoji/"+UnicodeVersion+"/emoji-test.txt", "fully-qualified")
	var extraVariations []string
	for _, seq := range variationSequences {
		if !slices.Contains(fullyQualifiedSequences, seq) {
			unifiedWithoutVS := strings.Split(seq, " ")[0]
			extraVariations = append(extraVariations, fmt.Sprintf(`\x{%s}`, unifiedWithoutVS))
		}
	}
	file := exerrors.Must(os.OpenFile("emojis.go", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644))
	exerrors.Must(file.WriteString(`// Code generated by go generate; DO NOT EDIT.

package variationselector

import (
	"regexp"
	"strings"
)

func doInit() {
`))
	exerrors.Must(file.WriteString("\tvariationRegex = regexp.MustCompile(\n"))
	exerrors.Must(file.WriteString("\t\t`(^|[^\\x{200D}])(` +\n\t\t\t`"))
	exerrors.Must(file.WriteString(strings.Join(extraVariations, "|` +\n\t\t\t`")))
	exerrors.Must(file.WriteString("` +\n\t\t\t`)([^\\x{FE0F}\\x{FE0E}\\x{200D}\\x{1F3FB}\\x{1F3FC}\\x{1F3FD}\\x{1F3FE}\\x{1F3FF}]|$)`,\n\t)\n"))
	exerrors.Must(file.WriteString("\tvar qualifiedEmojis = []string{\n"))
	for _, unified := range fullyQualifiedSequences {
		if !strings.Contains(unified, "FE0F") {
			continue
		}
		unicode := unifiedToUnicode(unified)
		exerrors.Must(fmt.Fprintf(file, "\t\t\"%s\",\n", unicode))
	}
	exerrors.Must(file.WriteString("\t}\n"))
	exerrors.Must(file.WriteString(`
	replacerArgs := make([]string, len(qualifiedEmojis)*2)
	for i, emoji := range qualifiedEmojis {
		replacerArgs[i*2] = strings.ReplaceAll(emoji, "\ufe0f", "")
		replacerArgs[(i*2)+1] = emoji
	}
`))
	exerrors.Must(file.WriteString("\tfullyQualifier = strings.NewReplacer(replacerArgs...)\n"))
	exerrors.Must(file.WriteString("}\n"))
}
